    ---
    title: "Data Model - ERD"
    categories: [unsupervised, descriptive-analytics]
    ---

    <div class="topic-meta">Updated: {{< meta date format='YYYY-MM-DD' >}}</div>

          Awesome idea. Make a mini app that *leans* on PKs/FKs and shows them off clearly. Here’s a polished, portfolio-ready plan you can build fast and talk about confidently.

          # Project concept: **ConfPlanner** (Conference planning & ticketing)

          A small multi-tenant app to manage conferences: venues, rooms, sessions, speakers, tickets, orders, attendees, check-ins. It naturally uses lots of required FKs, unique constraints, and through tables.

          ## Why this shines in a portfolio

          * Rich relational graph: parents/children, M2M with extra fields, partial uniques, check constraints.
          * Clean demos: seed a fake conference, buy tickets, assign seats, check in.
          * Visuals: auto-generated ERD + admin screens + a couple of cute dashboards.

          ---

          # Data model (concise ERD outline)

          * **Organization** 1—*→* **Conference**
          * **Conference** 1—*→* **Venue** 1—*→* **Room** 1—*→* **Seat**
          * **Conference** 1—*→* **TicketType** 1—*→* **Ticket** *→* **Attendee**
          * **Order** 1—*→* **OrderItem** (*TicketType* per item)
          * **Speaker** M—*↔*—M **Session** via **Talk** (through model with role)
          * **Session** *→* **Room**, constrained by time and capacity
          * **CheckIn** links **Ticket** to **Session** with a unique constraint (one check-in per ticket per session)

          ---

          # Core Django models (drop-in skeleton)

          ```python
          # confplanner/core/models.py
          from django.db import models
          from django.contrib.auth import get_user_model
          from django.db.models import Q, UniqueConstraint

          User = get_user_model()

          class Organization(models.Model):
              name = models.CharField(max_length=120, unique=True)
              owner = models.ForeignKey(User, on_delete=models.PROTECT, related_name="owned_orgs")

          class Conference(models.Model):
              org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="conferences")
              name = models.CharField(max_length=160)
              slug = models.SlugField()
              starts_at = models.DateTimeField()
              ends_at = models.DateTimeField()

              class Meta:
                  unique_together = [("org", "slug")]
                  constraints = [
                      models.CheckConstraint(check=Q(ends_at__gt=models.F("starts_at")), name="conf_dates_valid"),
                  ]

          class Venue(models.Model):
              conference = models.ForeignKey(Conference, on_delete=models.CASCADE, related_name="venues")
              name = models.CharField(max_length=160)
              address = models.CharField(max_length=255)

          class Room(models.Model):
              venue = models.ForeignKey(Venue, on_delete=models.CASCADE, related_name="rooms")
              name = models.CharField(max_length=80)
              capacity = models.PositiveIntegerField()

              class Meta:
                  unique_together = [("venue", "name")]

          class Seat(models.Model):
              room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name="seats")
              label = models.CharField(max_length=16)

              class Meta:
                  unique_together = [("room", "label")]

          class Speaker(models.Model):
              full_name = models.CharField(max_length=120)
              bio = models.TextField(blank=True)

          class Session(models.Model):
              conference = models.ForeignKey(Conference, on_delete=models.CASCADE, related_name="sessions")
              room = models.ForeignKey(Room, on_delete=models.PROTECT, related_name="sessions")
              title = models.CharField(max_length=160)
              starts_at = models.DateTimeField()
              ends_at = models.DateTimeField()

              class Meta:
                  constraints = [
                      models.CheckConstraint(check=Q(ends_at__gt=models.F("starts_at")), name="session_dates_valid"),
                      models.Index(fields=["conference", "starts_at"]),
                  ]

          class Talk(models.Model):
              """Through table for Speaker<->Session with roles (primary, panelist, etc.)"""
              session = models.ForeignKey(Session, on_delete=models.CASCADE, related_name="talks")
              speaker = models.ForeignKey(Speaker, on_delete=models.CASCADE, related_name="talks")
              role = models.CharField(max_length=32, default="speaker")

              class Meta:
                  unique_together = [("session", "speaker")]

          class TicketType(models.Model):
              conference = models.ForeignKey(Conference, on_delete=models.CASCADE, related_name="ticket_types")
              name = models.CharField(max_length=80)
              price_cents = models.PositiveIntegerField()
              seat_required = models.BooleanField(default=False)

              class Meta:
                  unique_together = [("conference", "name")]

          class Order(models.Model):
              buyer = models.ForeignKey(User, on_delete=models.PROTECT, related_name="orders")
              conference = models.ForeignKey(Conference, on_delete=models.PROTECT, related_name="orders")
              placed_at = models.DateTimeField(auto_now_add=True)
              total_cents = models.PositiveIntegerField(default=0)

          class OrderItem(models.Model):
              order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
              ticket_type = models.ForeignKey(TicketType, on_delete=models.PROTECT, related_name="order_items")
              quantity = models.PositiveIntegerField()

          class Attendee(models.Model):
              conference = models.ForeignKey(Conference, on_delete=models.PROTECT, related_name="attendees")
              full_name = models.CharField(max_length=120)
              email = models.EmailField()

              class Meta:
                  unique_together = [("conference", "email")]

          class Ticket(models.Model):
              ticket_type = models.ForeignKey(TicketType, on_delete=models.PROTECT, related_name="tickets")
              attendee = models.ForeignKey(Attendee, on_delete=models.PROTECT, related_name="tickets")
              seat = models.ForeignKey(Seat, on_delete=models.PROTECT, null=True, blank=True, related_name="tickets")
              issued_at = models.DateTimeField(auto_now_add=True)
              is_active = models.BooleanField(default=True)

              class Meta:
                  constraints = [
                      # At most one *active* ticket per attendee per ticket_type
                      UniqueConstraint(
                          fields=["ticket_type", "attendee"],
                          condition=Q(is_active=True),
                          name="uniq_active_ticket_per_type_attendee",
                      )
                  ]

          class CheckIn(models.Model):
              session = models.ForeignKey(Session, on_delete=models.CASCADE, related_name="checkins")
              ticket = models.ForeignKey(Ticket, on_delete=models.PROTECT, related_name="checkins")
              scanned_at = models.DateTimeField(auto_now_add=True)

              class Meta:
                  unique_together = [("session", "ticket")]
          ```

          ### A few deliberate choices to discuss in your write-up

          * `PROTECT` vs `CASCADE` demonstrates ownership vs reference.
          * Partial unique constraint on `Ticket` shows DB-level business rules.
          * Through model `Talk` shows M2M with payload.
          * Room/Seat hierarchy + capacity showcases required FKs and uniqueness.

          ---

          # Minimal features to implement (and demo)

          * **Public pages**: conference list → conference detail → sessions schedule.
          * **Ticket buying**: “Add to cart” (1–3 items), checkout (no payment; fake success), order summary.
          * **Seat assignment**: only for `seat_required` tickets; enforce one ticket per seat and <= room capacity.
          * **Check-in UI**: simple page to pick a session and “scan” a ticket code (UUID) → creates `CheckIn`.
          * **Admin**: register all models; add list filters/search; inline `Talk` editing under `Session`.

          ---

          # Seeds, tests, and guards (short & sweet)

          **Factories (model\_bakery or factory\_boy)**

          ```python
          # tests/factories.py (factory_boy sample)
          import factory
          from django.utils import timezone
          from core import models

          class OrganizationFactory(factory.django.DjangoModelFactory):
              class Meta: model = models.Organization
              name = factory.Faker("company")
              owner = factory.SubFactory("tests.factories.UserFactory")

          class ConferenceFactory(factory.django.DjangoModelFactory):
              class Meta: model = models.Conference
              org = factory.SubFactory(OrganizationFactory)
              name = factory.Faker("catch_phrase")
              slug = factory.Faker("slug")
              starts_at = factory.LazyFunction(lambda: timezone.now())
              ends_at = factory.LazyFunction(lambda: timezone.now() + timezone.timedelta(days=2))
          ```

          **Property-style tests (pytest + pytest-django + hypothesis)**

          ```python
          def test_active_ticket_uniqueness(db, attendee, ticket_type):
              from core.models import Ticket
              Ticket.objects.create(attendee=attendee, ticket_type=ticket_type, is_active=True)
              with pytest.raises(IntegrityError):
                  Ticket.objects.create(attendee=attendee, ticket_type=ticket_type, is_active=True)
          ```

          **Conflict tests**: attempt to delete a `Room` with sessions (`PROTECT` should fail), overbook a room (custom validator or signal), double check-in (unique\_together on CheckIn).

          ---

          # Diagram + docs

          * Add **django-extensions + Graphviz**:

            ```bash
            pip install django-extensions pygraphviz
            # settings.py: INSTALLED_APPS += ["django_extensions"]
            python manage.py graph_models core -o docs/schema.png
            ```
          * **README.md** sections:

            * architecture (why FKs/constraints), ERD image
            * local run (below), seed script, demo scenario
            * “Things I’d change with more time” (shows maturity)

          ---

          # Project skeleton

          ```
          confplanner/
            core/
              models.py
              admin.py
              serializers.py     # if you add DRF
              views.py
              urls.py
            tickets/
              services.py        # seat assignment/check-in helpers
            templates/
            static/
            tests/
            docs/
              schema.png
          README.md
          docker-compose.yml
          ```

          ---

          # Runbook (copy to README)

          ```bash
          python -m venv .venv && source .venv/bin/activate
          pip install django psycopg2-binary django-extensions pygraphviz
          django-admin startproject confplanner .
          python manage.py migrate
          python manage.py createsuperuser
          python manage.py loaddata demo.json   # provide a small fixture
          python manage.py runserver
          # optional: ERD
          python manage.py graph_models core -o docs/schema.png
          ```

          ---

          # Nice portfolio extras (quick wins)

          * **One-page “Data Integrity Showcase”**: list each constraint with a tiny example + screenshot of the error message when violated.
          * **Metrics page**: sessions by track, top speakers, check-ins per hour (simple aggregates).
          * **OpenAPI schema** (if you use DRF) + a short screencap of trying the endpoints.
          * **GitHub Actions**: run `pytest`, `flake8`, and `python manage.py makemigrations --check`.

          ---

          If you want, tell me whether you prefer a classic server-rendered Django app or DRF + a small frontend, and I’ll tailor the views/URLs and give you a couple of production-ready snippets (seat assignment service, check-in validator, admin config) you can paste straight in.

          -----

          Great question. As your model grows, the trick is to make the **ERD a living artifact** that’s auto-generated, reviewed, and versioned—never a one-off diagram. Here’s a tight stack + workflow that works really well with Django.

          # Core tools (Django-friendly)

          **1) Auto-generate diagrams from your models**

          * **django-extensions + Graphviz (or pygraphviz):** generate ERDs straight from `models.py`.

            ```bash
            pip install django-extensions pygraphviz
            # settings.py
            INSTALLED_APPS += ["django_extensions"]
            # Generate SVG for specific apps
            python manage.py graph_models accounts catalog posts -o docs/erd.svg
            ```

            Tip: SVG commits better than PNG and diffs nicely in PRs.

          **2) Cross-check with the real database**

          * **SchemaSpy** (DB → ERD): produces HTML + ER diagrams from your Postgres instance; great to catch drift between code and the actual DB.
          * **DBeaver / DataGrip / pgModeler:** click-to-draw ERDs and reverse-engineer from DB; handy for ad-hoc views and onboarding.

          **3) Migration quality gates**

          * **django-migration-linter:** blocks dangerous migrations (e.g., adding NOT NULL without default) in CI.
          * **django-test-migrations:** write tests that assert critical constraints/indexes exist after migrations.

          **4) Docs that live with code**

          * **MkDocs (or Sphinx) + Mermaid:** keep a hand-curated overview diagram for big-picture context; the detailed ERD stays auto-generated.

            * Store at `docs/schema.md` and embed `![ERD](erd.svg)`.

          **5) Data quality & drift**

          * **Great Expectations** (optional): assert invariants on prod data (e.g., “every business has ≤1 active logo”).
          * **pgMustard / pganalyze** (optional): performance review of join-heavy queries that emerge from complex FKs.

          # Simple, durable workflow

          **A) Make the code the source of truth**

          * You primarily generate ERD from Django models (not DB), then **validate** against the DB using SchemaSpy occasionally.

          **B) Pre-commit hook to keep diagrams fresh**

          ```yaml
          # .pre-commit-config.yaml
          repos:
          - repo: local
            hooks:
              - id: build-erd
                name: Build ERD
                entry: bash -c "python manage.py graph_models businesses assets templates posts -o docs/erd.svg"
                language: system
                pass_filenames: false
          ```

          **C) CI job to fail on schema drift**

          * Run `makemigrations --check` (ensures no unmade migrations).
          * Run `django-migration-linter` on new migrations.
          * Optionally spin up Postgres, migrate, run SchemaSpy, and publish HTML as a CI artifact.

          ```yaml
          # .github/workflows/schema.yml (snippet)
          - name: Check migrations
            run: |
              python manage.py makemigrations --check
              django-migration-linter --project-root .
          - name: Build ERD
            run: python manage.py graph_models businesses assets templates posts -o docs/erd.svg
          - name: Upload ERD
            uses: actions/upload-artifact@v4
            with:
              name: erd
              path: docs/erd.svg
          ```

          **D) Document ownership & delete semantics**

          * In each model’s docstring, note:

            * **Owner** (who “owns” it)
            * **on\_delete policy** (CASCADE/PROTECT/SET\_NULL + rationale)
            * Any key **Unique/Check constraints**
          * This makes the ERD meaningful to readers, not just boxes and lines.

          # Maintenance tips that scale

          * **Modular diagrams:** generate one ERD per app/bounded context (e.g., `businesses`, `assets`, `templates`) plus an all-in-one version. Big graphs stay readable.
          * **Named constraints:** always name `UniqueConstraint`/`CheckConstraint`. You’ll see stable names in diffs and SchemaSpy.
          * **Version templates:** keep `BaseTemplate(code, version)` and tag “latest” in data; your ERD then shows a clean linear evolution.
          * **Snapshot fields:** keep immutable snapshots (like `contact_snapshot`) in designs—document them clearly so teammates don’t try to “normalize them away.”
          * **Index hygiene:** when you add a frequent filter/join, add a matching `Index` in code and mention it in the model docstring (“supports query X”).
          * **Release checklist:** “ERD updated, migration lint clean, SchemaSpy diff reviewed.”

          # Recommended minimal set to start

          * `django-extensions` + `pygraphviz` (generate ERD)
          * `django-migration-linter` (guardrails)
          * `MkDocs` with `docs/erd.svg` committed (visible docs)
          * (Optional) `SchemaSpy` monthly/quarterly to catch drift

          If you want, tell me your current app labels and I’ll give you a ready-to-paste `graph_models` command plus a starter `mkdocs.yml` so your ERD publishes as a mini site.
